{"version":3,"sources":["context/WordPuzzleContext.tsx","constants.ts","helpers/validateCharGrid.ts","helpers/extractPuzzleAnswers.ts","helpers/validateDirection.ts","components/WordLetter/WordLetter.tsx","components/PuzzleSolvedPopup/PuzzleSolvedPopup.tsx","components/WordGrid/WordGrid.tsx","helpers/localeLanguage.ts","components/WordInfo/WordInfo.tsx","components/PuzzleInfo/PuzzleInfo.tsx","components/PuzzleCompletedPopup/PuzzleCompletedPopup.tsx","components/Modal/Modal.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["WordPuzzleContext","createContext","currWordPuzzle","source_language","word","character_grid","word_locations","target_language","setCurrWordPuzzle","currWordPuzzleIndex","setCurrWordPuzzleIndex","currSolvedWords","setCurrSolvedWords","solvedWordPuzzles","setSolvedWordPuzzles","allPuzzlesCompleted","setAllPuzzlesCompleted","wordPuzzles","WordPuzzleProvider","children","useState","wordData","Provider","value","DIRECTIONS","minGridSize","words","forEach","puzzle","length","randomChar","alphabet","Math","floor","random","validateLength","element","sign","validateCharGrid","charGrid","rowCount","i","push","row","rowIndex","charCount","extractPuzzleAnswers","translatedWordLocations","replace","match","validateDirection","currDirection","selectedWordLocation","xindex","yindex","lastSelectedLetter","parseInt","WordLetter","letter","setCurrDirection","isSelectingWord","setIsSelectingWord","setSelectedWordLocation","isLetterFound","isThisLetterSelected","setIsThisLetterSelected","useEffect","startSelect","dragSelect","validDirection","isSelectingWordCopy","stopSelect","className","onMouseDown","onMouseEnter","onMouseUp","onTouchStart","onTouchMove","onTouchEnd","PuzzleSolvedPopup","useContext","puzzlesRemaining","WordGrid","validatedCharGrid","setValidatedCharGrid","answerLocations","setAnswerLocations","solvedLetters","setSolvedLetters","isPuzzleSolved","setIsPuzzleSolved","checkSelectedLetters","checkIfPuzzleSolved","answer","isEqual","solvedLettersCopy","concat","solvedWordString","xy","solvedWordsCopy","solvedPuzzles","setTimeout","resetState","setNewWordPuzzle","renderWordGrid","map","includes","CSSTransition","in","classNames","unmountOnExit","timeout","localeLanguage","locale","Intl","DisplayNames","type","of","WordInfo","language","Object","values","index","_letter","PuzzleInfo","remainingPuzzles","PuzzleCompletedPopup","onClick","Modal","ReactDOM","createPortal","document","body","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","render","StrictMode","getElementById"],"mappings":"2qHAkBaA,EAAoBC,wBAAiC,CAC9DC,eAAgB,CACdC,gBAAiB,GACjBC,KAAM,GACNC,eAAgB,CAAC,CAAC,KAClBC,eAAgB,CAAC,GAAK,IACtBC,gBAAiB,IAEnBC,kBAAmB,kBAAM,MACzBC,oBAAqB,EACrBC,uBAAwB,kBAAM,MAC9BC,gBAAiB,GACjBC,mBAAoB,kBAAM,MAC1BC,kBAAmB,GACnBC,qBAAsB,kBAAM,MAC5BC,qBAAqB,EACrBC,uBAAwB,kBAAM,MAC9BC,YAAa,CAAC,CACZd,gBAAiB,GACjBC,KAAM,GACNC,eAAgB,CAAC,CAAC,KAClBC,eAAgB,CAAC,GAAK,IACtBC,gBAAiB,OAqCRW,EA7ByC,SAAC,GAA4C,IAA1CC,EAAyC,EAAzCA,SAAyC,EAC5EC,mBAASC,GAAxBJ,EAD2F,sBAEhDG,mBAAmB,IAF6B,mBAE3FP,EAF2F,KAExEC,EAFwE,OAG5CM,mBAAiB,GAH2B,mBAG3FX,EAH2F,KAGtEC,EAHsE,OAIpDU,mBAAmB,IAJiC,mBAI3FT,EAJ2F,KAI1EC,EAJ0E,OAK5CQ,oBAAkB,GAL0B,mBAK3FL,EAL2F,KAKtEC,EALsE,OAMtDI,mBAAqBH,EAAYR,IANqB,mBAM3FP,EAN2F,KAM3EM,EAN2E,KAQlG,OACE,cAACR,EAAkBsB,SAAnB,CACEC,MAAO,CACLrB,iBACAM,oBACAC,sBACAC,yBACAC,kBACAC,qBACAC,oBACAC,uBACAC,sBACAC,yBACAC,eAZJ,SAeGE,K,+CCxEDK,EACK,QADLA,EAEQ,WAFRA,EAGU,aAHVA,EAII,OAJJA,EAKO,UALPA,EAMS,YANTA,EAOE,KAPFA,EAQI,O,QCHJC,EAAc,WAChB,IAAIA,EAAc,EAElB,OADAC,EAAMC,SAAS,SAAAC,GAAM,OAAIA,EAAOvB,eAAewB,OAASJ,EAAcA,EAAcG,EAAOvB,eAAewB,OAAS,QAC5GJ,GAGLK,EAAa,kBAAMC,EAASC,KAAKC,MAAMD,KAAKE,SAASH,EAASF,UAC9DM,EAAiB,SAACC,GAAD,OAA4C,IAAvBJ,KAAKK,KAAKD,IA0BvCE,EAxBU,SAACV,GACtB,IAAIW,EAAQ,YAAOX,EAAOvB,gBAGpBmC,EAAWf,IAAgBc,EAASV,OAC1C,GAAGM,EAAeK,GACd,IAAI,IAAIC,EAAI,EAAGA,EAAID,EAAUC,IACzBF,EAASG,KAAK,CAACZ,MAcvB,OATAS,EAASZ,SAAQ,SAACgB,EAAKC,GACnB,IAAMC,EAAYpB,IAAgBkB,EAAId,OACtC,GAAGM,EAAeU,GACd,IAAI,IAAIJ,EAAI,EAAGA,EAAII,EAAWJ,IAC1BF,EAASK,GAAUF,KAAKZ,QAK7BS,GCzBIO,EARc,SAAC5C,GAC1B,IAAI6C,EAA0B,GAC9B,IAAK,IAAM3C,KAAQF,EAAeI,eAC9ByC,EAAwBL,KAAKtC,EAAK4C,QAAQ,SAAU,IAAIC,MAAM,WAElE,OAAOF,GC+BIG,G,MA7BW,SAAC,GAAgF,IAA9EC,EAA6E,EAA7EA,cAAeC,EAA8D,EAA9DA,qBAAsBC,EAAwC,EAAxCA,OAAQC,EAAgC,EAAhCA,OAChEC,EACCC,SAASJ,EAAqBA,EAAqBvB,OAAS,GAAG,IADhE0B,EAECC,SAASJ,EAAqBA,EAAqBvB,OAAS,GAAG,IAatE,QAAO,GACH,MAAOsB,GAAiBA,IAAkB3B,KAV1B+B,EAAuB,IAAMF,GAAYE,IAAyBD,GAUN,OAAO9B,EACnF,MAAO2B,GAAiBA,IAAkB3B,KAV3B+B,EAAuB,IAAMF,GAAYE,IAAyBD,GAUP,OAAO9B,EACjF,MAAO2B,GAAiBA,IAAkB3B,KAV7B+B,IAAyBF,GAAYE,EAAuB,IAAMD,GAUT,OAAO9B,EAC7E,MAAO2B,GAAiBA,IAAkB3B,KAV3B+B,IAAyBF,GAAYE,EAAuB,IAAMD,GAUP,OAAO9B,EACjF,MAAO2B,GAAiBA,IAAkB3B,KAVxB+B,EAAuB,IAAMF,GAAYE,EAAuB,IAAMD,GAUP,OAAO9B,EACxF,MAAO2B,GAAiBA,IAAkB3B,KAVtB+B,EAAuB,IAAMF,GAAYE,EAAuB,IAAMD,GAUL,OAAO9B,EAC5F,MAAO2B,GAAiBA,IAAkB3B,KAVzB+B,EAAuB,IAAMF,GAAYE,EAAuB,IAAMD,GAUR,OAAO9B,EACtF,MAAO2B,GAAiBA,IAAkB3B,KAVvB+B,EAAuB,IAAMF,GAAYE,EAAuB,IAAMD,GAUN,OAAO9B,EAC1F,QAAU,OAAO,KCoCViC,EArDI,SAAC,GAWG,IAVnBC,EAUkB,EAVlBA,OACAL,EASkB,EATlBA,OACAC,EAQkB,EARlBA,OACAH,EAOkB,EAPlBA,cACAQ,EAMkB,EANlBA,iBACAC,EAKkB,EALlBA,gBACAC,EAIkB,EAJlBA,mBACAT,EAGkB,EAHlBA,qBACAU,EAEkB,EAFlBA,wBACAC,EACkB,EADlBA,cACkB,EACsC3C,oBAAS,GAD/C,mBACX4C,EADW,KACWC,EADX,KAElBC,qBAAU,WAAWN,GAAiBK,GAAwB,KAAS,CAACL,IAExE,IAAMO,EAAc,WAChBL,EAAwB,CAAC,GAAD,OAAIT,GAAJ,OAAaC,KACrCW,GAAwB,GACxBJ,GAAmB,IAGjBO,EAAa,WACf,GAAGR,EAAiB,CAChB,IAAMS,EAAiBnB,EAAkB,CAACC,gBAAeC,uBAAsBC,SAAQC,WACvF,GAAGe,EAAgB,CACfV,EAAiBU,GACjB,IAAMC,EAAmB,sBAAOlB,GAAP,WAAgCC,GAAhC,OAAyCC,KAClEW,GAAwB,GACxBH,EAAwBQ,SAG5BT,GAAmB,IAIrBU,EAAa,WACfZ,GAAiB,GACjBE,GAAmB,GACnBC,EAAwB,CAAC,MAG7B,OACI,sBACIU,UAAWT,EAAgB,iCAAmCC,EAAuB,oCAAsC,cAC3HS,YAAa,kBAAMN,KACnBO,aAAc,kBAAMN,KACpBO,UAAW,kBAAMJ,KACjBK,aAAc,kBAAMT,KACpBU,YAAa,kBAAMT,KACnBU,WAAY,kBAAMP,KAPtB,SAQEb,KCtDKqB,G,MATW,WAAO,IAAD,EACaC,qBAAWhF,GAA7CiB,EADqB,EACrBA,YAAaJ,EADQ,EACRA,kBACdoE,EAAmBpE,GAAqBA,EAAkBgB,OAASZ,EAAYY,OACrF,OACI,qBAAK2C,UAAU,sBAAf,SACI,qFAAmDS,GAAoB,sBAAMT,UAAU,iCAAhB,4BAAvE,0BCiHGU,G,MA7GE,WAAO,IAAD,EAYfF,qBAAWhF,GAVXiB,EAFe,EAEfA,YACAf,EAHe,EAGfA,eACAM,EAJe,EAIfA,kBACAC,EALe,EAKfA,oBACAC,EANe,EAMfA,uBACAC,EAPe,EAOfA,gBACAC,EARe,EAQfA,mBACAC,EATe,EASfA,kBACAC,EAVe,EAUfA,qBACAE,EAXe,EAWfA,uBAXe,EAa+BI,mBAAqB,IAbpD,mBAaZ+D,EAbY,KAaOC,EAbP,OAcuBhE,oBAA2B,GAdlD,mBAcZ+B,EAdY,KAcGQ,EAdH,OAe2BvC,oBAAS,GAfpC,mBAeZwC,EAfY,KAeKC,EAfL,OAgBqCzC,mBAAmB,IAhBxD,mBAgBZgC,EAhBY,KAgBUU,EAhBV,OAiB2B1C,mBAA6B,IAjBxD,mBAiBZiE,EAjBY,KAiBKC,EAjBL,OAkBuBlE,mBAAmB,IAlB1C,mBAkBZmE,EAlBY,KAkBGC,EAlBH,OAmByBpE,oBAAS,GAnBlC,mBAmBZqE,EAnBY,KAmBIC,EAnBJ,KAqBnBxB,qBAAU,WACNoB,EAAmBxC,EAAqB5C,IACxCkF,EAAqB9C,EAAiBpC,MACvC,CAACA,IACJgE,qBAAU,kBAAMyB,MAAwB,CAACvC,IACzCc,qBAAU,kBAAM0B,MAAuB,CAACjF,IAExC,IAAMgF,EAAuB,WAEzBN,EAAgB1D,SAAQ,SAAAkE,GAEpB,GADkCC,IAAQD,EAAQzC,GACpB,CAE1B,IAAM2C,EAAiB,YAAOR,EAAcS,OAAO5C,IACnDoC,EAAiBO,GAGjB,IAAIE,EAAmB,GACvB7C,EAAqBzB,SAAS,SAAAuE,GAAE,OAAID,GAAsCC,EAAGlD,QAAQ,QAAS,UAE9F,IAAMmD,EAAe,2BAAOxF,GAAP,kBAAyBsF,EAAiBjD,QAAQ,QAAS,IAAM9C,EAAeI,eAAe2F,EAAiBjD,QAAQ,QAAS,OACtJpC,EAAmBuF,QAKzBP,EAAsB,WACxB,GAAGE,IAAQnF,EAAiBT,EAAeI,gBAAiB,CACxD,IAAM8F,EAAa,sBAAOvF,GAAP,CAA0BX,EAAeE,OAC5DU,EAAqBsF,GACrBV,GAAkB,GAClBW,YAAW,WACPC,KACAF,EAAcvE,OAASZ,EAAYY,OAAS0E,KAAqBvF,GAAuB,KNzD5E,QM8DlBsF,GAAa,WACfzC,GAAmB,GACnBC,EAAwB,IACxB0B,EAAiB,IACjB5E,EAAmB,IACnB8E,GAAkB,IAGhBa,GAAmB,WACrB/F,EAAkBS,EAAYR,EAAsB,IACpDC,EAAuBD,EAAsB,IAI3C+F,GAAiBrB,EAAkBsB,KAAI,SAAC9D,EAAeW,GACzD,OACI,qBAAsCkB,UAAU,iBAAhD,SACK7B,EAAI8D,KAAI,SAAC/C,EAAgBL,GACtB,OACI,cAAC,EAAD,CAEIK,OAAQA,EACRL,OAAQA,EACRC,OAAQA,EACRH,cAAeA,EACfQ,iBAAkBA,EAClBC,gBAAiBA,EACjBC,mBAAoBA,EACpBT,qBAAsBA,EACtBU,wBAAyBA,EACzBC,cAAewB,EAAcmB,SAAd,UAA0BrD,GAA1B,OAAmCC,KAV7CpD,EAAeE,KAAKsD,EAAOL,OAJtCnD,EAAeE,KAAKkD,MAsBtC,OACI,sBAAKkB,UAAWiB,EAAiB,8BAAgC,YAAjE,UACKe,GACD,cAACG,EAAA,EAAD,CAAeC,GAAInB,EAAgBoB,WAAW,SAASC,eAAa,EAACC,QAAS,IAA9E,SACI,sBAAMvC,UAAU,yBAEpB,cAACmC,EAAA,EAAD,CAAeC,GAAInB,EAAgBoB,WAAW,YAAYC,eAAa,EAACC,QAAS,IAAjF,SACI,cAAC,EAAD,WChHDC,EALQ,SAACC,GAEpB,OAD+B,IAAKC,KAAaC,aAAa,CAAC,MAAO,CAAEC,KAAM,aAChDC,GAAGJ,ICsCtBK,G,MAnCE,WAAO,IAAD,EACuBtC,qBAAWhF,GAA9CE,EADY,EACZA,eAAgBS,EADJ,EACIA,gBACjB4G,EAAWP,EAAe9G,EAAeK,iBAgB/C,OACI,sBAAKiE,UAAU,YAAf,UACI,sBAAKA,UAAU,kBAAf,UACI,oBAAIA,UAAU,sDAAd,kBACA,oBAAIA,UAAU,yCAAd,SAAwDtE,EAAeE,UAE3E,sBAAKoE,UAAU,kBAAf,UACI,oBAAIA,UAAU,yBAAd,sBACA,oBAAIA,UAAU,yCAAd,SAAwD+C,OAE5D,gCACI,oBAAI/C,UAAU,yBAAd,0BAzBqBgD,OAAOC,OAAOvH,EAAeI,gBAAgBmG,KAAI,SAACrG,EAAMsH,GACrF,OACItH,EACA,qBAAsBoE,UAAU,kBAAhC,SACMgD,OAAOC,OAAO9G,GAAiB+F,SAAStG,GACtC,oBAAeoE,UAAU,yFAAzB,SAAmHpE,GAA1GA,GAET,oBAAeoE,UAAU,2FAAzB,SAAqH,YAAIpE,GAAMqG,KAAI,SAACkB,GAAD,MAAa,QAAvIvH,IAJPA,EAAKsH,GAOb,gBCGCE,G,MAlBI,WAAO,IAAD,EACoC5C,qBAAWhF,GAA7DiB,EADc,EACdA,YAAaf,EADC,EACDA,eAAgBW,EADf,EACeA,kBAE9BgH,EAAmB5G,EAAYwF,KAAI,SAAC7E,EAAQ8F,GAAT,OAAoB7G,EAAkB6F,SAAS9E,EAAOxB,OAASF,EAAeE,OAASwB,EAAOxB,KAAsF,KAA/E,oBAA4BoE,UAAU,oBAAtC,SAA2D5C,EAAOxB,MAAzDwB,EAAOxB,KAAKsH,MAEnK,OACI,sBAAKlD,UAAU,cAAf,UACI,oBAAIA,UAAU,qBAAd,4BACA,qBAAKA,UAAU,mBAAf,SACI,oBAAIA,UAAU,iDAAd,SAAgE3D,EAAkBgB,OAAU,MAAQZ,EAAYY,WAEpH,oBAAI2C,UAAU,qBAAd,+BACA,qBAAKA,UAAU,mBAAf,SACKqD,SCOFC,G,MApBc,WAAO,IAAD,EACgF9C,qBAAWhF,GAAnHiB,EADwB,EACxBA,YAAaH,EADW,EACXA,qBAAsBJ,EADX,EACWA,uBAAwBF,EADnC,EACmCA,kBAAmBQ,EADtD,EACsDA,uBASrF,OACI,qBAAKwD,UAAU,yBAAf,SACI,sBAAKA,UAAU,+BAAf,UACI,qBAAIA,UAAU,sCAAd,oDAA4FvD,EAAYY,OAAxG,2BACA,wBAAQ2C,UAAU,SAASuD,QAAS,kBAV5CjH,EAAqB,IACrBJ,EAAuB,GACvBF,EAAkBS,EAAY,SAC9BD,GAAuB,IAOf,+BCVDgH,G,MAFe,SAAC,GAAD,IAAE7G,EAAF,EAAEA,SAAF,OAA4B8G,IAASC,aAAa,qBAAK1D,UAAU,QAAf,SAAwBrD,IAAiBgH,SAASC,Q,MCwBnHC,MAlBf,WAAgB,IACPtH,EAAuBiE,qBAAWhF,GAAlCe,oBACP,OACE,qBAAKyD,UAAU,MAAf,SACE,sBAAKA,UAAU,eAAf,UACE,cAAC,EAAD,IACA,cAAC,EAAD,IACA,cAAC,EAAD,IACA,cAACmC,EAAA,EAAD,CAAeC,GAAI7F,EAAqB8F,WAAW,SAASC,eAAa,EAACC,QAAS,EAAnF,SACE,cAAC,EAAD,UACE,cAAC,EAAD,cCRGuB,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCFdN,IAASc,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,UACE,cAAC,EAAD,QAGJb,SAASc,eAAe,SAM1BX,M","file":"static/js/main.3245b539.chunk.js","sourcesContent":["import { createContext, useState, FC, ReactElement } from 'react';\nimport wordData from './../assets/data/words.json'\nimport {WordPuzzle} from './types'\n\ninterface WordPuzzleContext {\n  currWordPuzzle: WordPuzzle\n  setCurrWordPuzzle: (value: WordPuzzle) => void,\n  currWordPuzzleIndex: number,\n  setCurrWordPuzzleIndex: (value: number) => void,\n  currSolvedWords: string[]\n  setCurrSolvedWords: (value: string[]) => void,\n  solvedWordPuzzles: string[],\n  setSolvedWordPuzzles: (value: string[]) => void,\n  allPuzzlesCompleted: boolean,\n  setAllPuzzlesCompleted: (value: boolean) => void,\n  wordPuzzles: WordPuzzle[]\n}  \n\nexport const WordPuzzleContext = createContext<WordPuzzleContext>({\n    currWordPuzzle: {\n      source_language: '',\n      word: '',\n      character_grid: [['']],\n      word_locations: {'' : ''},\n      target_language: ''\n    },\n    setCurrWordPuzzle: () => null,\n    currWordPuzzleIndex: 0,\n    setCurrWordPuzzleIndex: () => null,\n    currSolvedWords: [],\n    setCurrSolvedWords: () => null,\n    solvedWordPuzzles: [],\n    setSolvedWordPuzzles: () => null,\n    allPuzzlesCompleted: false,\n    setAllPuzzlesCompleted: () => null,\n    wordPuzzles: [{\n      source_language: '',\n      word: '',\n      character_grid: [['']],\n      word_locations: {'' : ''},\n      target_language: ''\n    }],\n})\n\ninterface WordPuzzleProviderProps {\n  children: ReactElement,\n}\n\nconst WordPuzzleProvider: FC<WordPuzzleProviderProps> = ({ children } : WordPuzzleProviderProps) => {\n  const [wordPuzzles] = useState(wordData)\n  const [solvedWordPuzzles, setSolvedWordPuzzles] = useState<string[]>([])\n  const [currWordPuzzleIndex, setCurrWordPuzzleIndex] = useState<number>(0)\n  const [currSolvedWords, setCurrSolvedWords] = useState<string[]>([])\n  const [allPuzzlesCompleted, setAllPuzzlesCompleted] = useState<boolean>(false)\n  const [currWordPuzzle, setCurrWordPuzzle] = useState<WordPuzzle>(wordPuzzles[currWordPuzzleIndex])\n\n  return (\n    <WordPuzzleContext.Provider\n      value={{\n        currWordPuzzle,\n        setCurrWordPuzzle,\n        currWordPuzzleIndex,\n        setCurrWordPuzzleIndex,\n        currSolvedWords,\n        setCurrSolvedWords,\n        solvedWordPuzzles,\n        setSolvedWordPuzzles,\n        allPuzzlesCompleted,\n        setAllPuzzlesCompleted,\n        wordPuzzles\n      }}\n    >\n      {children}\n    </WordPuzzleContext.Provider>\n  );\n};\n\nexport default WordPuzzleProvider\n","const DIRECTIONS = {\n    RIGHT: 'right',\n    RIGHT_UP: 'right_up',\n    RIGHT_DOWN: 'right_down',\n    LEFT: 'left',\n    LEFT_UP: 'left_up',\n    LEFT_DOWN: 'left_down',\n    UP: 'up',\n    DOWN: 'down'\n}\nconst PUZZLE_SOLVED_DELAY = 3300\n\nexport {\n    DIRECTIONS,\n    PUZZLE_SOLVED_DELAY\n}","import words from './../assets/data/words.json'\nimport alphabet from './../assets/data/alphabet.json'\nimport {WordPuzzle} from './../context/types'\n\n\nconst minGridSize = () => {\n    let minGridSize = 0\n    words.forEach((puzzle => puzzle.character_grid.length > minGridSize ? minGridSize = puzzle.character_grid.length : null))\n    return minGridSize\n}\n\nconst randomChar = () => alphabet[Math.floor(Math.random()*alphabet.length)]\nconst validateLength = (element: number) => Math.sign(element) === 1\n\nconst validateCharGrid = (puzzle: WordPuzzle) => {\n    let charGrid = [...puzzle.character_grid]\n\n    // check if rows equal minGridSize, and if not random populate\n    const rowCount = minGridSize() - charGrid.length\n    if(validateLength(rowCount)) {\n        for(let i = 0; i < rowCount; i++) {\n            charGrid.push([randomChar()])\n        }\n    } \n\n    // check if row chars equal minGridSize, and if not random populate\n    charGrid.forEach((row, rowIndex) => {\n        const charCount = minGridSize() - row.length\n        if(validateLength(charCount)) {\n            for(let i = 0; i < charCount; i++) {\n                charGrid[rowIndex].push(randomChar())\n            }\n        }\n    })\n\n    return charGrid\n}\n\nexport default validateCharGrid","import { WordPuzzle } from \"../context/types\"\n\nconst extractPuzzleAnswers = (currWordPuzzle: WordPuzzle) => {\n    let translatedWordLocations = []\n    for (const word in currWordPuzzle.word_locations) {\n        translatedWordLocations.push(word.replace(/[ ,.]/g, \"\").match(/(..?)/g))\n    }\n    return translatedWordLocations as RegExpMatchArray[]\n}\n\nexport default extractPuzzleAnswers","import {DIRECTIONS} from './../constants'\n\ninterface ValidateDirection {\n    currDirection: string | boolean\n    selectedWordLocation: string[]\n    xindex: number\n    yindex: number\n}\n\nconst validateDirection = ({ currDirection, selectedWordLocation, xindex, yindex }: ValidateDirection) => {\n    const lastSelectedLetter = {\n        x: parseInt(selectedWordLocation[selectedWordLocation.length - 1][0]),\n        y: parseInt(selectedWordLocation[selectedWordLocation.length - 1][1]),\n    }\n\n    //this is not ideal but could not think of the MATH to run this cleaner\n    const checkRight = (lastSelectedLetter.x + 1 === xindex) && (lastSelectedLetter.y === yindex)\n    const checkLeft = (lastSelectedLetter.x - 1 === xindex) && (lastSelectedLetter.y === yindex)\n    const checkUp = (lastSelectedLetter.x === xindex) && (lastSelectedLetter.y - 1 === yindex)\n    const checkDown = (lastSelectedLetter.x === xindex) && (lastSelectedLetter.y + 1 === yindex)\n    const checkRightUp = (lastSelectedLetter.x + 1 === xindex) && (lastSelectedLetter.y - 1 === yindex)\n    const checkRightDown = (lastSelectedLetter.x + 1 === xindex) && (lastSelectedLetter.y + 1 === yindex)\n    const checkLeftUp = (lastSelectedLetter.x - 1 === xindex) && (lastSelectedLetter.y - 1 === yindex)\n    const checkLeftDown = (lastSelectedLetter.x - 1 === xindex) && (lastSelectedLetter.y + 1 === yindex)\n\n    switch(true) {\n        case (!currDirection || currDirection === DIRECTIONS.RIGHT) && checkRight : return DIRECTIONS.RIGHT\n        case (!currDirection || currDirection === DIRECTIONS.LEFT) && checkLeft : return DIRECTIONS.LEFT\n        case (!currDirection || currDirection === DIRECTIONS.UP) && checkUp : return DIRECTIONS.UP\n        case (!currDirection || currDirection === DIRECTIONS.DOWN) && checkDown : return DIRECTIONS.DOWN\n        case (!currDirection || currDirection === DIRECTIONS.RIGHT_UP) && checkRightUp : return DIRECTIONS.RIGHT_UP\n        case (!currDirection || currDirection === DIRECTIONS.RIGHT_DOWN) && checkRightDown : return DIRECTIONS.RIGHT_DOWN\n        case (!currDirection || currDirection === DIRECTIONS.LEFT_UP) && checkLeftUp : return DIRECTIONS.LEFT_UP\n        case (!currDirection || currDirection === DIRECTIONS.LEFT_DOWN) && checkLeftDown : return DIRECTIONS.LEFT_DOWN\n        default : return false\n    }\n}\n\nexport default validateDirection","import {useEffect, useState, Dispatch, SetStateAction} from 'react'\nimport './WordLetter.scss'\nimport validateDirection from './../../helpers/validateDirection'\n\ninterface WordLetterType {\n    letter: string\n    xindex: number\n    yindex: number\n    currDirection: string | boolean\n    setCurrDirection: Dispatch<SetStateAction<string | boolean>>\n    isSelectingWord: boolean \n    setIsSelectingWord: Dispatch<SetStateAction<boolean>>\n    selectedWordLocation: string[] \n    setSelectedWordLocation: Dispatch<SetStateAction<string[]>>\n    isLetterFound: boolean\n}\n\nconst WordLetter = ({\n    letter, \n    xindex, \n    yindex, \n    currDirection, \n    setCurrDirection, \n    isSelectingWord, \n    setIsSelectingWord, \n    selectedWordLocation, \n    setSelectedWordLocation, \n    isLetterFound\n}: WordLetterType) => {\n    const [isThisLetterSelected, setIsThisLetterSelected] = useState(false)\n    useEffect(() => {if(!isSelectingWord) setIsThisLetterSelected(false)}, [isSelectingWord])\n\n    const startSelect = () => {\n        setSelectedWordLocation([`${xindex}${yindex}`])\n        setIsThisLetterSelected(true)\n        setIsSelectingWord(true)\n    }\n\n    const dragSelect = () => { \n        if(isSelectingWord) {\n            const validDirection = validateDirection({currDirection, selectedWordLocation, xindex, yindex})\n            if(validDirection) {\n                setCurrDirection(validDirection)\n                const isSelectingWordCopy = [...selectedWordLocation, `${xindex}${yindex}`]\n                setIsThisLetterSelected(true)\n                setSelectedWordLocation(isSelectingWordCopy)\n            }\n        } else {\n            setIsSelectingWord(false)\n        }\n    }\n\n    const stopSelect = () => {\n        setCurrDirection(false)\n        setIsSelectingWord(false)\n        setSelectedWordLocation([''])\n    }\n    \n    return (\n        <span \n            className={isLetterFound ? 'word-letter word-letter--found' : isThisLetterSelected ? 'word-letter word-letter--selected' : 'word-letter'} \n            onMouseDown={() => startSelect()} \n            onMouseEnter={() => dragSelect()}\n            onMouseUp={() => stopSelect()}\n            onTouchStart={() => startSelect()} \n            onTouchMove={() => dragSelect()}  \n            onTouchEnd={() => stopSelect()}\n        >{letter}</span>\n    )\n}\nexport default WordLetter","import {useContext} from 'react'\nimport {WordPuzzleContext} from '../../context/WordPuzzleContext'\nimport './PuzzleSolvedPopup.scss'\n\nconst PuzzleSolvedPopup = () => {\n    const {wordPuzzles, solvedWordPuzzles} = useContext(WordPuzzleContext)\n    const puzzlesRemaining = solvedWordPuzzles && solvedWordPuzzles.length < wordPuzzles.length\n    return (\n        <div className=\"puzzle-solved-popup\">\n            <h4>ðŸ¥³&nbsp;&nbsp;Congratulations puzzle solved. { puzzlesRemaining && <span className=\"puzzle-solved-popup__highlight\">Onto the next </span>}&nbsp;ðŸ’ª</h4>\n        </div>\n    )\n}\nexport default PuzzleSolvedPopup","import {useContext, useState, useEffect} from 'react';\nimport {WordPuzzleContext} from '../../context/WordPuzzleContext'\nimport {CSSTransition} from 'react-transition-group'\nimport isEqual from 'lodash.isequal'\n\nimport {PUZZLE_SOLVED_DELAY} from '../../constants'\nimport validateCharGrid from '../../helpers/validateCharGrid'\nimport extractPuzzleAnswers from '../../helpers/extractPuzzleAnswers'\n\nimport WordLetter from '../WordLetter/WordLetter'\nimport PuzzleSolvedPopup from '../PuzzleSolvedPopup/PuzzleSolvedPopup'\nimport './WordGrid.scss'\n\nconst WordGrid = () => {\n    const {\n        wordPuzzles, \n        currWordPuzzle, \n        setCurrWordPuzzle, \n        currWordPuzzleIndex, \n        setCurrWordPuzzleIndex,\n        currSolvedWords,\n        setCurrSolvedWords,\n        solvedWordPuzzles, \n        setSolvedWordPuzzles,\n        setAllPuzzlesCompleted\n    } = useContext(WordPuzzleContext)\n    const [validatedCharGrid, setValidatedCharGrid] = useState<string[][]>([])\n    const [currDirection, setCurrDirection] = useState<string | boolean>(false)\n    const [isSelectingWord, setIsSelectingWord] = useState(false)\n    const [selectedWordLocation, setSelectedWordLocation] = useState<string[]>([])\n    const [answerLocations, setAnswerLocations] = useState<RegExpMatchArray[]>([])\n    const [solvedLetters, setSolvedLetters] = useState<string[]>([])\n    const [isPuzzleSolved, setIsPuzzleSolved] = useState(false)\n\n    useEffect(() => { \n        setAnswerLocations(extractPuzzleAnswers(currWordPuzzle)) \n        setValidatedCharGrid(validateCharGrid(currWordPuzzle))\n    }, [currWordPuzzle])\n    useEffect(() => checkSelectedLetters(), [selectedWordLocation])\n    useEffect(() => checkIfPuzzleSolved(), [currSolvedWords])\n\n    const checkSelectedLetters = () => {\n        //loop through the translation answers and check if the selected letters match any and if they do save them\n        answerLocations.forEach(answer => {\n            const selectedWordMatchesAnswer = isEqual(answer, selectedWordLocation)\n            if(selectedWordMatchesAnswer) {\n            //save solved letters so that we can permanently highlight them\n                const solvedLettersCopy = [...solvedLetters.concat(selectedWordLocation)]\n                setSolvedLetters(solvedLettersCopy)\n            //save solved words so that we can keep track if the puzzle has been solved\n                //1. stringify the selected word xy values\n                let solvedWordString = ''\n                selectedWordLocation.forEach( xy => solvedWordString = solvedWordString + xy.replace(/.{1}/g, '$&,'))\n                //2. update solved words with original data structure of xy corrdinates as the key and name as the value\n                const solvedWordsCopy = {...currSolvedWords, [solvedWordString.replace(/,\\s*$/, \"\")]: currWordPuzzle.word_locations[solvedWordString.replace(/,\\s*$/, \"\")]}\n                setCurrSolvedWords(solvedWordsCopy)\n            }\n        })\n    }\n\n    const checkIfPuzzleSolved = () => {\n        if(isEqual(currSolvedWords, currWordPuzzle.word_locations)) {\n            const solvedPuzzles = [...solvedWordPuzzles, currWordPuzzle.word]\n            setSolvedWordPuzzles(solvedPuzzles)\n            setIsPuzzleSolved(true)\n            setTimeout(() => {\n                resetState()\n                solvedPuzzles.length < wordPuzzles.length ? setNewWordPuzzle() : setAllPuzzlesCompleted(true)\n            }, PUZZLE_SOLVED_DELAY)\n        }\n    }\n\n    const resetState = () => {\n        setIsSelectingWord(false)\n        setSelectedWordLocation([])\n        setSolvedLetters([])\n        setCurrSolvedWords([])\n        setIsPuzzleSolved(false)\n    }\n    \n    const setNewWordPuzzle = () => {\n        setCurrWordPuzzle(wordPuzzles[currWordPuzzleIndex + 1])\n        setCurrWordPuzzleIndex(currWordPuzzleIndex + 1)\n    }\n    \n\n    const renderWordGrid = validatedCharGrid.map((row: string[], yindex: number) => {\n        return (\n            <div key={currWordPuzzle.word+yindex} className=\"word-grid__row\">\n                {row.map((letter: string, xindex: number) => {\n                    return (\n                        <WordLetter \n                            key={currWordPuzzle.word+letter+xindex} \n                            letter={letter}\n                            xindex={xindex}\n                            yindex={yindex}\n                            currDirection={currDirection}\n                            setCurrDirection={setCurrDirection}\n                            isSelectingWord={isSelectingWord} \n                            setIsSelectingWord={setIsSelectingWord}\n                            selectedWordLocation={selectedWordLocation}\n                            setSelectedWordLocation={setSelectedWordLocation}\n                            isLetterFound={solvedLetters.includes(`${xindex}${yindex}`)}\n                        />\n                    )}\n                )}\n            </div>\n        )\n    })\n    \n    return (\n        <div className={isPuzzleSolved ? 'word-grid word-grid--freeze' : 'word-grid'}>\n            {renderWordGrid}\n            <CSSTransition in={isPuzzleSolved} classNames=\"appear\" unmountOnExit timeout={200}>\n                <span className=\"word-grid__overlay\" />\n            </CSSTransition>\n            <CSSTransition in={isPuzzleSolved} classNames=\"appear-up\" unmountOnExit timeout={200}>\n                <PuzzleSolvedPopup />\n            </CSSTransition>\n        </div>\n    )\n}\nexport default WordGrid","const localeLanguage = (locale : string) => {\n    const languageNamesInEnglish = new (Intl as any).DisplayNames(['en'], { type: 'language' })\n    return languageNamesInEnglish.of(locale)\n}\n\nexport default localeLanguage","import {useContext} from 'react';\nimport localeLanguage from '../../helpers/localeLanguage'\nimport {WordPuzzleContext} from '../../context/WordPuzzleContext'\nimport './WordInfo.scss'\n\nconst WordInfo = () => {\n    const {currWordPuzzle, currSolvedWords} = useContext(WordPuzzleContext)\n    const language = localeLanguage(currWordPuzzle.target_language)\n\n    const renderTranslations = () => Object.values(currWordPuzzle.word_locations).map((word, index) => {\n        return (\n            word ? \n            <div key={word+index} className=\"word-info__item\"> \n                { Object.values(currSolvedWords).includes(word) ? \n                    <h4 key={word} className=\"word-info__item word-info__item__value word-info__item word-info__item__value--success\">{word}</h4> \n                    :\n                    <h4 key={word} className=\"word-info__item word-info__item__value word-info__item word-info__item__value--highlight\">{[...word].map((_letter) => '_')}</h4> \n                }\n            </div>\n            : null\n        )    \n    })\n\n    return (\n        <div className=\"word-info\">\n            <div className=\"word-info__item\">\n                <h4 className=\"word-info__item__label word-info__item__label--word\">Word</h4>\n                <h4 className=\"word-info__item word-info__item__value\">{currWordPuzzle.word}</h4>\n            </div>\n            <div className=\"word-info__item\">\n                <h4 className=\"word-info__item__label\">Language</h4>\n                <h4 className=\"word-info__item word-info__item__value\">{language}</h4>\n            </div>\n            <div>\n                <h4 className=\"word-info__item__label\">Translations</h4>\n                {renderTranslations()}\n            </div>\n        </div>\n    )\n}\nexport default WordInfo","import {useContext} from 'react';\nimport {WordPuzzleContext} from '../../context/WordPuzzleContext'\nimport './PuzzleInfo.scss'\n\nconst PuzzleInfo = () => {\n    const {wordPuzzles, currWordPuzzle, solvedWordPuzzles} = useContext(WordPuzzleContext)\n    \n    const remainingPuzzles = wordPuzzles.map((puzzle, index) => !solvedWordPuzzles.includes(puzzle.word) && currWordPuzzle.word !== puzzle.word ? <h4 key={puzzle.word+index} className=\"puzzle-info__item\">{puzzle.word}</h4> : null)\n\n    return (\n        <div className=\"puzzle-info\">\n            <h4 className=\"puzzle-info__label\">Solved puzzles</h4>      \n            <div className=\"puzzle-info__row\">\n                <h4 className=\"puzzle-info__item puzzle-info__item--highlight\">{solvedWordPuzzles.length +  ' / ' + wordPuzzles.length}</h4>\n            </div>\n            <h4 className=\"puzzle-info__label\">Remaining puzzles</h4>      \n            <div className=\"puzzle-info__row\">\n                {remainingPuzzles}\n            </div>\n        </div>\n    )\n}\nexport default PuzzleInfo","import {useContext} from 'react';\nimport {WordPuzzleContext} from '../../context/WordPuzzleContext'\nimport './PuzzleCompletedPopup.scss'\n\nconst PuzzleCompletedPopup = () => {\n    const {wordPuzzles, setSolvedWordPuzzles, setCurrWordPuzzleIndex, setCurrWordPuzzle, setAllPuzzlesCompleted} = useContext(WordPuzzleContext)\n    \n    const resetPuzzle = () => {\n        setSolvedWordPuzzles([])\n        setCurrWordPuzzleIndex(0)\n        setCurrWordPuzzle(wordPuzzles[0])\n        setAllPuzzlesCompleted(false)\n    }\n\n    return (\n        <div className=\"puzzle-completed-popup\">\n            <div className=\"puzzle-completed-popup__copy\">\n                <h3 className=\"puzzle-completed-popup__copy__title\">Congratulations you have completed all {wordPuzzles.length} puzzles ðŸ¥³</h3>\n                <button className=\"button\" onClick={() => resetPuzzle()}>Start over</button>\n            </div>\n        </div>\n    )\n}\n\nexport default PuzzleCompletedPopup","import ReactDOM from 'react-dom'\nimport {FC, ReactElement} from 'react';\nimport './Modal.scss';\n\ninterface ModalProps {children: ReactElement}\n\nconst Modal: FC<ModalProps> = ({children}: ModalProps) => ReactDOM.createPortal(<div className=\"modal\">{children}</div>, document.body)\n\nexport default Modal","import {useContext} from 'react';\nimport {WordPuzzleContext} from './context/WordPuzzleContext'\nimport {CSSTransition} from 'react-transition-group'\n\nimport WordGrid from './components/WordGrid/WordGrid'\nimport WordInfo from './components/WordInfo/WordInfo'\nimport PuzzleInfo from './components/PuzzleInfo/PuzzleInfo'\nimport PuzzleCompletedPopup from './components/PuzzleCompletedPopup/PuzzleCompletedPopup'\nimport Modal from './components/Modal/Modal'\nimport './App.scss';\n\n\nfunction App() {\n  const {allPuzzlesCompleted} = useContext(WordPuzzleContext)\n  return (\n    <div className=\"app\">\n      <div className=\"app__wrapper\">\n        <WordInfo />\n        <WordGrid />\n        <PuzzleInfo />\n        <CSSTransition in={allPuzzlesCompleted} classNames=\"appear\" unmountOnExit timeout={0}>\n          <Modal>\n            <PuzzleCompletedPopup />\n          </Modal>\n        </CSSTransition>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './scss/global/global.scss'\nimport App from './App';\nimport WordPuzzleProvider from './context/WordPuzzleContext'\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <WordPuzzleProvider>\n      <App />\n    </WordPuzzleProvider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}